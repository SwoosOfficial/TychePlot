 
    #
    #
    #   returns List with arithmetic averaged values, List with standarddeviation values for each Char(OLED)
    @functools.lru_cache()
    def processAvg_old(self):
        avgDataList=[]
        devDataList=[]
        superDataList=self.dataList
        for m in range(0,len(superDataList)):
            avgTempData=superDataList[0][0].getData()*0
            devTempData=superDataList[0][0].getData()*0
            for n in range(0,len(superDataList[m])):
                tempData=superDataList[m][n].getData()
                avgTempData+=tempData
            avgData=avgTempData/len(superDataList[m])
            for n in range(0,len(superDataList[m])):
                tempData=superDataList[m][n].getData()
                devTempData+=np.square(np.subtract(avgData,tempData))
            devData=np.sqrt(devTempData/len(superDataList[m]))
            avgDataList.append(avgData)
            devDataList.append(devData)
        return avgDataList, devDataList
    #
    #
    #   returns List with median averaged values, List with standarddeviation values for each Char(OLED)
    @functools.lru_cache()
    def processMedian_old(self):
        dataList=self.dataList
        voltList=[[data.getData()[:,0] for data in deviceData] for deviceData in dataList]
        curList=[[data.getData()[:,1] for data in deviceData] for deviceData in dataList]
        lumList=[[data.getData()[:,2] for data in deviceData] for deviceData in dataList]
        lumEfficList=[[data.getData()[:,3] for data in deviceData] for deviceData in dataList]
        curEfficList=[[data.getData()[:,4] for data in deviceData] for deviceData in dataList]
        EQEList=[[data.getData()[:,5] for data in deviceData] for deviceData in dataList]
        medVoltList=[np.median(volt, axis=0) for volt in voltList]
        medCurList=[np.median(cur, axis=0) for cur in curList]
        medLumList=[np.median(lum, axis=0) for lum in lumList]
        medLumEfficList=[np.median(lumEffic, axis=0) for lumEffic in lumEfficList]
        medCurEfficList=[np.median(curEffic, axis=0) for curEffic in curEfficList]
        medEQEList=[np.median(EQE, axis=0) for EQE in EQEList]
        medData=[Data.mergeData([volt,medCur,medLum,medLumEffic,medCurEffic,medEQE]) for volt,medCur,medLum,medLumEffic,medCurEffic,medEQE in zip(medVoltList,medCurList,medLumList,medLumEfficList,medCurEfficList,medEQEList)]
        devData=[np.sqrt(np.sum([np.square(np.subtract(data,tempData.getData())) for tempData in deviceData], axis=0)/len(deviceData))  for data, deviceData in zip(medData, dataList)]
        return medData, devData
    
    def processAverage_old(self):
        if self.averageMedian:
            expectData, deviaData = self.processMedian()
        else:
            expectData, deviaData = self.processAvg()
        self.expectData=[Data(data) for data in expectData]
        self.deviaData=[Data(data) for data in deviaData]
        return self.expectData, self.deviaData
    
    def logErr_old(self):
        if not self.overrideErrorTypes:
            if self.showColAxType[self.showCol] is "log":
                self.errorTypeUp=0
                self.errorTypeDown=0
            else:
                self.errorTypeUp=1
                self.errorTypeDown=1
            if self.showColAxType[self.showCol2] is "log":
                self.lumerrorTypeUp=0
                self.lumerrorTypeDown=0
            else:
                self.lumerrorTypeUp=1
                self.lumerrorTypeDown=1
        expectData=self.expectData
        deviaData=self.deviaData
        minData=[np.amin([data.getData() for data in deviceData], axis=0) for deviceData in self.dataList]
        maxData=[np.amax([data.getData() for data in deviceData], axis=0) for deviceData in self.dataList]
        symErr=[(np.absolute(expect.getData()-devia.getData())) for devia,expect in zip(deviaData, expectData)]
        minErr=[np.absolute(expect.getData()-mind) for devia,expect,mind in zip(deviaData, expectData, minData)]
        maxErr=[np.absolute(expect.getData()-maxi) for devia,expect,maxi in zip(deviaData, expectData, maxData)]
        logErrMin=[np.minimum(err, mind) for err,mind in zip(symErr,minErr)]
        logErrMax=[np.minimum(err, maxi) for err,maxi in zip(symErr,maxErr)]
        return [logErrMin,logErrMax]
    
    def processPlot_old(self):
        expectData=self.expectData
        colors=self.colors
        labels=self.labels
        showCol=self.showCol
        showCol2=self.showCol2
        colorOffset=self.colorOffset
        ax=self.ax
        ax2=self.ax2
        for n in range(0,len(expectData)):
            if self.show[n][0]:
                if self.errors[n][0]:
                    UI=ax.errorbar(*expectData[n].getSplitData2D(yCol=showCol), yerr=[self.logErr()[self.errorTypeDown][n][:,showCol-1],self.logErr()[self.errorTypeUp][n][:,showCol-1]], c=colors[n], capsize=self.capsize, capthick=self.capthick , ls="-", label=labels[n])
                else:
                    UI=ax.errorbar(*expectData[n].getSplitData2D(yCol=showCol), c=colors[n], ls="-", label=labels[n])
                for a in UI[1]:
                    a.set_alpha(self.erroralphabar)
                for b in UI[2]:
                    b.set_alpha(self.erroralpha)
            if self.show[n][1]:
                if self.errors[n][1]:
                    UL=ax2.errorbar(*expectData[n].getSplitData2D(yCol=showCol2), yerr=[self.logErr()[self.lumerrorTypeDown][n][:,showCol2-1],self.logErr()[self.lumerrorTypeUp][n][:,showCol2-1]], capsize=self.capsize, capthick=self.capthick, c=colors[n+colorOffset], ls="--", label=labels[n]+" Luminance")
                else:
                    UL=ax2.errorbar(*expectData[n].getSplitData2D(yCol=showCol2), c=colors[n+colorOffset], ls="--", label=labels[n]+" Luminance")
                for a in UL[1]:
                    a.set_alpha(self.lumerroralpha)
                for b in UL[2]:
                    b.set_alpha(self.lumerroralphabar)
                    
    def doPlot_old(self):
        self.ax = self._newFig()[1]
        ax= self.ax
        ax.set_xlabel(self.xLabel)
        if self.showColAxType[self.xCol] is "log":
            ax.set_xscale("log", basex=10, subsy=[2,3,4,5,6,7,8,9])
        ax.set_ylabel(self.axYLabel)
        if self.showColAxType[self.showCol] is "log":
            ax.set_yscale("log", basex=10, subsy=[2,3,4,5,6,7,8,9])
        ax.set_ylim(*self.axYLim)
        ax.grid(alpha=0.5, ls=":")
        if True in [a[1] for a in self.show]:
            self.ax2= ax.twinx()
            ax2=self.ax2
            ax2.set_ylabel(self.ax2YLabel)
            if self.showColAxType[self.showCol2] is "log":
                ax2.set_yscale("log", basex=10, subsy=[2,3,4,5,6,7,8,9])
            ax2.set_ylim(*self.ax2YLim)
        self.processData()
        self.processAverage()
        self.processPlot()
        handles, labels=ax.get_legend_handles_labels()
        handles = [h[0] for h in handles]
        labels = labels[0:len(self.fileList)]
        if True in [a[1] for a in self.show]:
            handles2, labels2=ax2.get_legend_handles_labels()
            handles2 = [h[0] for h in handles2]
            labels2 = labels2[0:len(self.fileList)]
            handles=handles+handles2
            labels=labels+labels2
        leg=ax.legend(handles, labels, loc=2, numpoints=1)
        leg.get_frame().set_linewidth(self.legendEdgeSize)
        if self.titleBool:
            ax.set_title(self.title, fontsize="x-large")
        matplotlib.pyplot.tight_layout()
        self.saveFig()
        self.rescaleRcParams()
        return self.processFileName(option=".pdf") #filename

      

